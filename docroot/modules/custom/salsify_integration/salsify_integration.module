<?php

/**
 * @file
 * The Salsify integration module.
 */

use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\salsify_integration\Form\ConfigForm;

/**
 * Implements hook_cron().
 */
function salsify_integration_midnight_import() {
  $aproach = \Drupal::config('salsify_integration.settings')->get('approach');
  if ($aproach == ConfigForm::SALSIFY_API_APPROACH) {
    $product_feed = \Drupal::service('salsify_integration.salsify_fields');
    $force_update = (bool) \Drupal::config('salsify_integration.settings')->get('cron_force_update');

    // ImportProductData is quite a huge operation.
    // Check number of items in order to avoid meaningless work.
    $number_of_items = \Drupal::queue('salsify_integration_content_import')->numberOfItems();
    if ($number_of_items == 0) {
      $product_feed->importProductData($force_update);
    }

    \Drupal::logger('salsify_integration')
      ->notice('The Salsify data is queued to be imported and will be processed on the next cron run.');

    \Drupal::service('salsify_integration.email_report')
      ->sendReportByCron();
  }
}

/**
 * Implements hook_token_info().
 */
function salsify_integration_token_info() {
  $info['tokens']['salsify']['validation_errors'] = [
    'name' => t('All validation errors during Salsify data import'),
    'description' => t(
      'All validation errors during Salsify dataimport.'
    ),
  ];
  $info['tokens']['salsify']['deleted_items'] = [
    'name' => t('All deleted entities during Salisify data import'),
    'description' => t(
      'All deleted entities during Salisify data import.'
    ),
  ];

  return $info;
}

/**
 * Implements hook_tokens().
 */
function salsify_integration_tokens(
  $type,
  $tokens,
  array $data,
  $options,
  BubbleableMetadata $bubbleable_metadata
) {
  $replacements = [];
  foreach ($tokens as $name => $value) {
    if ($name === 'validation_errors') {
      $replacements['[salsify:validation_errors]'] = '@validation_errors';
    }
    if ($name === 'deleted_items') {
      $replacements['[salsify:deleted_items]'] = '@deleted_items';
    }
  }

  return $replacements;
}

/**
 * Implements hook_mail_alter().
 */
function salsify_integration_mail_alter(&$message) {
  $validation_errors_msg = t('Salsify import validation errors (GTIN, Salsify field, type):');
  pass_report_data_to_email(
    $message,
    'validation_errors',
    $validation_errors_msg
    );

  $deleted_items_msg = t('Salsify sync deleted items (GTIN):');
  pass_report_data_to_email(
    $message,
    'deleted_items',
    $deleted_items_msg
    );
}

/**
 * Pass salsify report data to email body.
 *
 * @param array $message
 *   Message array.
 * @param string $param_name
 *   Param name.
 * @param string $head_text
 *   Heading text.
 */
function pass_report_data_to_email(
  array &$message,
  string $param_name,
  string $head_text
) {
  if (isset($message['params'][$param_name])) {
    $items = $message['params'][$param_name];

    $items_msg = $head_text . '\r\n';
    foreach ($items as $item) {
      $items_msg .= $item . '\r\n';
    }

    $items_msg = (!empty($items)) ? $items_msg : '';
    if (isset($message['body'][0])) {
      $message['body'][0] = strtr($message['body'][0], [
        '@' . $param_name => $items_msg,
      ]);
    }
  }
}

/**
 * Implements callback_allowed_values_function().
 *
 * @see options_allowed_values()
 */
function salsify_integration_allowed_values_callback(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL) {
  $options_config = \Drupal::config('salsify_integration.field_options');
  $salsify_id = salsify_integration_get_salsify_id($definition->getName(), $entity->getEntityTypeId(), $entity->bundle());
  if ($salsify_id) {
    $options = $options_config->get($salsify_id[0]);
    if ($options) {
      return $options;
    }
  }
  return [];
}

/**
 * Looks up a Drupal field's Salsify ID from the mapping table.
 */
function salsify_integration_get_salsify_id($field_name, $entity_type, $entity_bundle) {
  $query = \Drupal::database()->select('config', 'c')
    ->fields('c', ['data']);
  $like_salsify_integration = $query->escapeLike('salsify_integration');
  $like_field_name = $query->escapeLike($entity_type . '.' . $entity_bundle . '.' . $field_name);
  $data = $query->condition('name', $like_salsify_integration . '%', 'LIKE')
    ->condition('name', '%' . $like_field_name, 'LIKE')
    ->range(0, 1)
    ->execute()
    ->fetchCol('data');
  if ($data) {
    $config = unserialize($data[0]);
    return $config['field_id'];
  }
  else {
    return FALSE;
  }
}

/**
 * Utility function to clean up Salsify data if fields are deleted from Drupal.
 *
 * @param \Drupal\field\Entity\FieldConfig $field
 *   The field being deleted from the system.
 */
function salsify_integration_field_config_delete(FieldConfig $field) {
  // Get the field name and use it to look up the field_id from the mapping
  // table.
  $field_name = $field->get('field_name');
  $entity_type = $field->get('entity_type');
  $entity_bundle = $field->get('bundle');
  $field_storage = FieldStorageConfig::loadByName($entity_type, $field_name);
  $salsify = \Drupal::service('salsify_integration.salsify_fields');

  if ($field_storage) {
    // If the field is still set somewhere on the system, then don't remove it
    // and leave the field mapping intact.
    $entity_bundles = $field_storage->getBundles();

    // Perform the deletion logic on the Salsify data.
    if (empty($entity_bundles)) {
      $field_id = salsify_integration_get_salsify_id($field_name, $entity_type, $entity_bundle)[0];
      $salsify->removeFieldOptions($field_id);
      $salsify->deleteFieldMapping([
        'method' => 'manual',
        'entity_type' => $entity_type,
        'bundle' => $entity_bundle,
        'field_name' => $field_name,
      ]);
      $salsify->deleteFieldMapping([
        'method' => 'dynamic',
        'entity_type' => $entity_type,
        'bundle' => $entity_bundle,
        'field_name' => $field_name,
      ]);
    }
  }
  else {
    $salsify->deleteFieldMapping([
      'method' => 'manual',
      'entity_type' => $entity_type,
      'bundle' => $entity_bundle,
      'field_name' => $field_name,
    ]);
    $salsify->deleteFieldMapping([
      'method' => 'dynamic',
      'entity_type' => $entity_type,
      'bundle' => $entity_bundle,
      'field_name' => $field_name,
    ]);
  }
}

/**
 * Implements hook_theme().
 */
function salsify_integration_theme() {
  return [
    // Normally theme suggestion templates are only picked up when they are in
    // themes. Define theme suggestions here so that the block templates in
    // the templates directory are picked up.
    'salsify_field' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field',
      'template' => 'salsify-field',
    ],
    'salsify_field__boolean' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field__',
      'template' => 'salsify-field--boolean',
    ],
    'salsify_field__link' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field__',
      'template' => 'salsify-field--link',
    ],
    'salsify_field__html' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field__',
      'template' => 'salsify-field--html',
    ],
  ];
}

/**
 * Helper function that adds the proper theme handler for each Salsify field.
 */
function salsify_integration_setup_field_render_arrays(array $field_data) {
  $render_array = [];
  foreach ($field_data as $id => $field) {
    $field_array = [
      'title' => [
        '#value' => t('@title', ['@title' => $field['salsify:name']]),
        '#attributes' => [
          'class' => ['field-title'],
        ],
      ],
      '#theme' => 'salsify_field',
    ];
    switch ($field['salsify:data_type']) {
      case 'boolean':
        $field_array['#theme'] = 'salsify_field__boolean';
        break;

      case 'html':

      case 'rich_text':
        $field_array['#theme'] = 'salsify_field__html';
        break;

      case 'link':
        $field_array['#theme'] = 'salsify_field__link';
        break;

      default:
        break;

    }
    $render_array[$id] = $field_array;
  }
  return $render_array;
}

/**
 * Helper function that adds the field values into the provided render array.
 */
function salsify_integration_setup_value_render_arrays(array &$field_data, array $product_data) {
  foreach ($field_data as $key => &$field) {
    $field['field_value'] = [
      '#value' => isset($product_data[$key]) ? $product_data[$key] : '',
    ];
  }
}

/**
 * Request Salsify for the new data.
 */
function salsify_integration_cron_salsify_request() {
  $aproach = \Drupal::config('salsify_integration.settings')->get('approach');
  if ($aproach == ConfigForm::SALSIFY_MULTICHANNEL_APPROACH) {
    /** @var \Drupal\salsify_integration\Run\RunResource $service */
    $service = \Drupal::service('salsify_integration.salsify.runs');
    $available_languages = \Drupal::languageManager()->getLanguages();
    foreach ($available_languages as $language) {
      $langcode = $language->getId();
      $service->create($langcode);
      $service->read($langcode);
    }
  }
}

/**
 * Import new data from Salsify.
 */
function salsify_integration_cron_salsify_import() {
  $aproach = \Drupal::config('salsify_integration.settings')->get('approach');
  if ($aproach == ConfigForm::SALSIFY_MULTICHANNEL_APPROACH) {
    /** @var \Drupal\salsify_integration\MigrationRunner $service */
    $service = \Drupal::service('salsify_integration.migrations.products');
    $service->runProductMigration();
  }
}
